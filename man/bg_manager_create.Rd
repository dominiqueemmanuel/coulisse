% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bg_manager.R
\name{bg_manager_create}
\alias{bg_manager_create}
\title{Créer un gestionnaire de jobs en arrière-plan}
\usage{
bg_manager_create(
  session = shiny::getDefaultReactiveDomain(),
  max_workers = 1L,
  default_timeout_ms = 120000L,
  start_timeout_ms = NA_integer_,
  beat_fast_ms = 200L,
  beat_slow_ms = 3000L,
  default_use_qs = TRUE,
  cleanup_qs = TRUE,
  notify = "none",
  verbosity = "info",
  queue_limit = Inf,
  idle_shutdown_s = 300L,
  r_default_packages = c("base", "stats", "utils"),
  extra_env = NULL,
  write_notify_table = FALSE,
  notify_dir = tempdir(),
  fast_collect = TRUE,
  watcher = c("signals", "beat"),
  signals_dir = tempdir(),
  signals_interval_ms = 100L,
  timeout_fallback_ms = 3000L
)
}
\arguments{
\item{session}{domaine reactif Shiny}

\item{max_workers}{nombre maximal de jobs en parallele}

\item{default_timeout_ms}{timeout d'execution par job (ms)}

\item{start_timeout_ms}{timeout de demarrage (ms) (NA = desactive)}

\item{beat_fast_ms}{periode de poll quand il y a du travail (ms)}

\item{beat_slow_ms}{periode de poll quand idle (ms)}

\item{default_use_qs}{TRUE = serialiser via qs par defaut, sinon retour direct}

\item{cleanup_qs}{TRUE = supprime le fichier .qs apres lecture}

\item{notify}{"none"|"shiny"|"message"|function(type,text)}

\item{verbosity}{"silent"|"info"|"debug"|"hard_debug"}

\item{queue_limit}{taille max de la file (Inf = illimite)}

\item{idle_shutdown_s}{reserve pour engine 'session' (non utilise ici)}

\item{r_default_packages}{vector of package names for R_DEFAULT_PACKAGES in workers}

\item{extra_env}{named character vector of extra env vars for workers (optional)}

\item{write_notify_table}{logical. Si TRUE, ecrit un log JSON Lines de tous les notify}

\item{notify_dir}{dossier ou ecrire le/les fichiers JSONL}

\item{fast_collect}{logical (si TRUE, court-cictuite le get_result et  lis directement le .qs)}

\item{watcher}{\code{"beat"} (par défaut) ou \code{"signals"}. Sélectionne le mécanisme de réveil.}

\item{signals_dir}{Chemin du répertoire où les processus enfants écrivent les fichiers
de signal (\code{*.sig}) en mode \code{watcher = "signals"}. Par défaut \code{tempdir()}.}

\item{signals_interval_ms}{Intervalle (ms) du \code{start_sig_watcher()} pour contrôler la
fréquence de vérification de la \code{mtime} des fichiers de signaux.}

\item{timeout_fallback_ms}{Intervalle (ms) d'un tick de secours \emph{léger} utilisé
uniquement lorsqu'il y a des jobs actifs, afin d'évaluer les timeouts de démarrage/exécution
même si aucun nouveau signal n'arrive. Ignoré lorsqu'il n'y a pas de jobs actifs.}
}
\value{
Un objet \code{coulisse_manager}.
}
\description{
Construit et initialise un \emph{manager} pour soumettre et suivre des jobs
(processus R) démarrés via \code{callr::r_bg()}, avec collecte des résultats,
gestion des timeouts, callbacks, et intégration Shiny.
}
\details{
Deux modes de réveil (watchers) sont disponibles :
\itemize{
\item \strong{"beat"} (historique) : une boucle \code{observe()} + \code{invalidateLater()} réveille
régulièrement la logique (polling périodique).
\item \strong{"signals"} (nouveau) : un \code{start_sig_watcher()} observe un répertoire de \emph{signaux}
(fichiers \code{*.sig}) écrits par les processus enfants ; ne relit que si quelque chose a changé.
}
}
\examples{
\dontrun{
mgr <- bg_manager_create(watcher = "signals",
                         signals_dir = tempdir(),
                         signals_interval_ms = 500L)
}
}
